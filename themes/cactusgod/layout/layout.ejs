<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <% var title = []; if (page.title) title.push(page.title);
    title.push(config.title); %> <% if (config.author){ %>
    <meta name="author" content="<%= config.author %>" />
    <% } %> <% if (page.description){ %>
    <meta name="description" content="<%= page.description %>" />
    <% } else if (config.description){ %>
    <meta name="description" content="<%= config.description %>" />
    <% } else if (page.excerpt){ %>
    <meta
      name="description"
      content="<%= strip_html(page.excerpt).replace(/^\s*/, '').replace(/\s*$/, '') %>"
    />
    <% } else if (page.content){ %>
    <meta
      name="description"
      content="<%= strip_html(page.content).replace(/^\s*/, '').replace(/\s*$/, '').substring(0, 150) %>"
    />
    <% } %> <% if (page.title){ %>
    <meta property="og:title" content="<%= page.title %>" />
    <% } %>
    <meta property="og:site_name" content="<%= config.title %>" />

    <% if(page.cover) { %>
    <meta property="og:image" content="<%= page.cover %>" />
    <% } else { %>
    <meta property="og:image" content="<%= config.cover %>" />
    <% } %> <%- favicon_tag('/img/favicon.ico') %> <% if (config.feed) { %> <%-
    feed_tag() %> <% } else if (theme.rss) { %> <%- feed_tag(theme.rss) %> <% }
    %>
    <title><%= title.join(' | ') %></title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif&family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap"
      rel="stylesheet"
    />
    <%- css('css/blog.css') %>
  </head>
  <body>
    <div id="three"></div>
    <div class="container">
      <%- partial('_partial/header') %> <%- body %> <%-
      partial('_partial/footer') %>
    </div>
    <!-- <script src="/js/index.js"></script> -->
    <script type="module">
      import * as THREE from "/js/three.module.js";
      import * as GeometryUtils from "/js/GeometryUtils.js";

      let renderer, scene, camera;
      const objects = [];

      let xpos = 10;
      let ypos = 0;
      const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
      function findScreenCoords(mouseEvent) {
        if (mouseEvent) {
          //FireFox
          xpos = mouseEvent.screenX;
          ypos = mouseEvent.screenY;
        } else {
          //IE
          xpos = window.event.screenX;
          ypos = window.event.screenY;
        }
        xpos = clamp(xpos / window.innerWidth - 0.5, -0.5, 0.5) * 2;
        ypos = clamp(ypos / window.innerHeight - 0.5, -0.5, 0.5) * 2;
      }
      document.body.onmousemove = findScreenCoords;

      const WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight;

      init();
      animate();

      function init() {
        camera = new THREE.PerspectiveCamera(60, WIDTH / HEIGHT, 1, 200);
        camera.position.z = 150;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202225);
        scene.fog = new THREE.Fog(0x111111, 150, 200);

        const subdivisions = 6;
        const recursion = 1;

        const points = GeometryUtils.hilbert3D(
          new THREE.Vector3(0, 0, 0),
          25.0,
          recursion,
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7
        );
        const spline = new THREE.CatmullRomCurve3(points);

        const samples = spline.getPoints(points.length * subdivisions);
        const geometrySpline = new THREE.BufferGeometry().setFromPoints(
          samples
        );

        const geometryBox = box(50, 50, 50);

        const lineSegments = new THREE.LineSegments(
          geometryBox,
          new THREE.LineBasicMaterial({
            color: 0x308ad9,
            linewidth: 1,
          })
        );
        lineSegments.computeLineDistances();

        objects.push(lineSegments);
        scene.add(lineSegments);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(WIDTH, HEIGHT);

        const three = document.getElementById("three");
        three.appendChild(renderer.domElement);

        window.addEventListener("resize", onWindowResize);
      }

      function box(width, height, depth) {
        (width = width * 0.5), (height = height * 0.5), (depth = depth * 0.5);

        const geometry = new THREE.BufferGeometry();
        const position = [];

        position.push(
          -width,
          -height,
          -depth,
          -width,
          height,
          -depth,

          -width,
          height,
          -depth,
          width,
          height,
          -depth,

          width,
          height,
          -depth,
          width,
          -height,
          -depth,

          width,
          -height,
          -depth,
          -width,
          -height,
          -depth,

          -width,
          -height,
          depth,
          -width,
          height,
          depth,

          -width,
          height,
          depth,
          width,
          height,
          depth,

          width,
          height,
          depth,
          width,
          -height,
          depth,

          width,
          -height,
          depth,
          -width,
          -height,
          depth,

          -width,
          -height,
          -depth,
          -width,
          -height,
          depth,

          -width,
          height,
          -depth,
          -width,
          height,
          depth,

          width,
          height,
          -depth,
          width,
          height,
          depth,

          width,
          -height,
          -depth,
          width,
          -height,
          depth
        );

        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(position, 3)
        );

        return geometry;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        render();
      }

      function render() {
        const time = Date.now() * 0.001;

        const scale = 1.25;
        let index = 0;
        scene.traverse(function (object) {
          if (object.isLine) {
            const scaledIndex = scale * index++;
            object.rotation.x = 0.25 * time;
            object.rotation.y = 0.25 * time;
            object.position.x = xpos * 20;
            object.position.y = -ypos * 20;
          }
        });

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
