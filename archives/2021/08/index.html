<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
     
    <meta name="author" content="Jeremy" />
     
    <meta name="description" content="Technical specifications of the forever 2012 album." />
     
    <meta property="og:site_name" content="Cactus God" />

    
    <meta property="og:image" content="" />
     <link rel="shortcut icon" href="/img/favicon.ico">  <link rel="alternate" href="/atom.xml" title="Cactus God" type="application/atom+xml"> 
    <title>Cactus God</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=IBM+Plex+Serif&family=Source+Sans+Pro:ital,wght@0,400;0,700;1,400&display=swap"
      rel="stylesheet"
    />
    
<link rel="stylesheet" href="/css/blog.css">

  <meta name="generator" content="Hexo 5.4.0"></head>
  <body>
    <div id="three"></div>
    <div class="container">
      <header>
  <ul class="blog-nav">
    
    <li class="blog-nav-item">
      <a href="/">Home</a>
    </li>
    
    <li class="blog-nav-item">
      <a href="/about">About</a>
    </li>
    
  </ul>
  <h1>
    <span class="header-title">Cactus God</span
    ><span class="blinking-cursor">|</span>
  </h1>
  <div class="header-line"></div>
</header>
  <footer>
    &#169; 2021 Cactus God | Jeremy
</footer>
    </div>
    <!-- <script src="/js/index.js"></script> -->
    <script type="module">
      import * as THREE from "/js/three.module.js";
      import * as GeometryUtils from "/js/GeometryUtils.js";

      let renderer, scene, camera;
      const objects = [];

      let xpos = 10;
      let ypos = 0;
      const clamp = (num, min, max) => Math.min(Math.max(num, min), max);
      function findScreenCoords(mouseEvent) {
        if (mouseEvent) {
          //FireFox
          xpos = mouseEvent.screenX;
          ypos = mouseEvent.screenY;
        } else {
          //IE
          xpos = window.event.screenX;
          ypos = window.event.screenY;
        }
        xpos = clamp(xpos / window.innerWidth - 0.5, -0.5, 0.5) * 2;
        ypos = clamp(ypos / window.innerHeight - 0.5, -0.5, 0.5) * 2;
      }
      document.body.onmousemove = findScreenCoords;

      const WIDTH = window.innerWidth,
        HEIGHT = window.innerHeight;

      init();
      animate();

      function init() {
        camera = new THREE.PerspectiveCamera(60, WIDTH / HEIGHT, 1, 200);
        camera.position.z = 150;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x202225);
        scene.fog = new THREE.Fog(0x111111, 150, 200);

        const subdivisions = 6;
        const recursion = 1;

        const points = GeometryUtils.hilbert3D(
          new THREE.Vector3(0, 0, 0),
          25.0,
          recursion,
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7
        );
        const spline = new THREE.CatmullRomCurve3(points);

        const samples = spline.getPoints(points.length * subdivisions);
        const geometrySpline = new THREE.BufferGeometry().setFromPoints(
          samples
        );

        const geometryBox = box(50, 50, 50);

        const lineSegments = new THREE.LineSegments(
          geometryBox,
          new THREE.LineBasicMaterial({
            color: 0x308ad9,
            linewidth: 1,
          })
        );
        lineSegments.computeLineDistances();

        objects.push(lineSegments);
        scene.add(lineSegments);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(WIDTH, HEIGHT);

        const three = document.getElementById("three");
        three.appendChild(renderer.domElement);

        window.addEventListener("resize", onWindowResize);
      }

      function box(width, height, depth) {
        (width = width * 0.5), (height = height * 0.5), (depth = depth * 0.5);

        const geometry = new THREE.BufferGeometry();
        const position = [];

        position.push(
          -width,
          -height,
          -depth,
          -width,
          height,
          -depth,

          -width,
          height,
          -depth,
          width,
          height,
          -depth,

          width,
          height,
          -depth,
          width,
          -height,
          -depth,

          width,
          -height,
          -depth,
          -width,
          -height,
          -depth,

          -width,
          -height,
          depth,
          -width,
          height,
          depth,

          -width,
          height,
          depth,
          width,
          height,
          depth,

          width,
          height,
          depth,
          width,
          -height,
          depth,

          width,
          -height,
          depth,
          -width,
          -height,
          depth,

          -width,
          -height,
          -depth,
          -width,
          -height,
          depth,

          -width,
          height,
          -depth,
          -width,
          height,
          depth,

          width,
          height,
          -depth,
          width,
          height,
          depth,

          width,
          -height,
          -depth,
          width,
          -height,
          depth
        );

        geometry.setAttribute(
          "position",
          new THREE.Float32BufferAttribute(position, 3)
        );

        return geometry;
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        render();
      }

      function render() {
        const time = Date.now() * 0.001;

        const scale = 1.25;
        let index = 0;
        scene.traverse(function (object) {
          if (object.isLine) {
            const scaledIndex = scale * index++;
            object.rotation.x = 0.25 * time;
            object.rotation.y = 0.25 * time;
            object.position.x = xpos * 20;
            object.position.y = -ypos * 20;
          }
        });

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
